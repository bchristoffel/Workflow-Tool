<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AutonomyWorks Workflow</title>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
  >
  <style>
    /* Basic reset / general styling */
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Segoe UI', sans-serif;
    }

    /* LOADING OVERLAY for pulling tasks */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: none; /* shown dynamically */
      align-items: center; 
      justify-content: center; 
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 9999;
    }
    #loadingOverlay .loadingBox {
      background: white;
      padding: 30px 50px;
      border-radius: 8px;
      text-align: center;
      font-size: 18px;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .overlaySpinner {
      width: 40px;
      height: 40px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #333;
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* LOGIN OVERLAY STYLES */
    #loginOverlay {
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%;
      background:
        radial-gradient(ellipse at center, rgba(20,30,60,0.15) 0%, rgba(20,40,70,0.8) 70%, rgba(20,40,70,1) 100%),
        url('https://images.unsplash.com/photo-1542744173-8e7e53415bb0?auto=format&fit=crop&w=1350&q=80')
          no-repeat center center fixed;
      background-size: cover;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000; /* above the page but below loading overlay */
    }
    .login-container {
      background: rgba(255,255,255,0.94);
      width: 360px;
      padding: 30px;
      border-radius: 14px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.25);
      text-align: center;
    }
    .login-header {
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 24px;
      color: #0d3b66;
      margin-bottom: 24px;
    }
    .login-header i {
      margin-left: 8px;
      font-size: 24px;
      color: #000;
    }
    input, button {
      width: 100%;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 15px;
      font-family: 'Segoe UI', sans-serif;
    }
    input {
      border: 1px solid #ccc;
      transition: border 0.2s;
    }
    .input-error {
      border-color: red !important;
    }
    button {
      border: none;
      background: #b2ebf2;
      color: #00332d;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #9adee6;
    }
    #loginSpinner {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    #loginSpinner .dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin: 3px;
      background-color: #333;
      border-radius: 50%;
      animation: wave 1.2s infinite ease-in-out;
    }
    #loginSpinner .dot:nth-child(1) {
      animation-delay: 0s;
    }
    #loginSpinner .dot:nth-child(2) {
      animation-delay: 0.12s;
    }
    #loginSpinner .dot:nth-child(3) {
      animation-delay: 0.24s;
    }
    @keyframes wave {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-8px); }
    }

    /* MAIN TASK SCREEN */
    #taskScreen {
      display: none; 
      width: 100%; 
      height: 100%;
      background-color: #f0f0f0;
      overflow: auto; 
      padding: 20px;
      position: relative;
      z-index: 1; /* to ensure it’s behind any overlay if shown */
    }
    #greeting {
      text-align: center;
      margin: 0 auto 20px auto;
      font-size: 22px; 
      color: #1d3330;
    }

    /* Notification bar for success/error messages */
    #notificationBar {
      display: none; 
      width: 100%; 
      text-align: center; 
      font-weight: 600; 
      padding: 8px 0; 
      margin-bottom: 10px;
    }

    /* Make the "Start Task" button shorter and wider */
    #startTaskBtn {
      width: 220px;
      height: 50px;
      font-size: 16px;
    }

    /* Task detail in a grid */
    .details-grid {
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 10px;
      max-width: 800px; 
      margin: 0 auto; 
      background: #fff;
      padding: 20px; 
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    @media(max-width: 600px) {
      .details-grid {
        grid-template-columns: 1fr;
      }
    }

    /* STOP TASK + statuses */
    #statusOptions {
      display: none; 
      margin: 20px auto; 
      max-width: 800px; 
      text-align: center;
    }
    .status-container {
      display: flex; 
      justify-content: center; 
      gap: 20px;
      margin-top: 20px;
    }
    #notes {
      display: none; /* hidden until a status is chosen */
      width: 100%;
      margin-top: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      font-size: 14px;
      font-family: 'Segoe UI', sans-serif;
      transition: border 0.2s;
    }
    /* Move Stop Task to bottom */
    .stop-task-container {
      margin-top: 20px;
    }
    .stop-btn {
      width: 150px;
      height: 40px;
      font-size: 15px;
      font-weight: 600;
      background: #b2ebf2;
      color: #00332d;
      cursor: pointer;
      border: none;
      border-radius: 4px;
    }
    .stop-btn:hover {
      background: #9adee6;
    }
    #stopSpinner {
      display: none;
      margin: 10px auto;
      width: 30px; 
      height: 30px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #333;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    /* ON CALL MODAL */
    #onCallModal {
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: white; 
      padding: 20px; 
      border-radius: 14px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.25);
      text-align: center; 
      max-width: 90vw; 
      width: 600px;
      font-family:'Segoe UI', sans-serif;
      z-index: 999; 
    }
    iframe {
      width: 100%; 
      height: 400px; 
      border: none;
    }

    /* Logout link at bottom, centered, smaller font */
    .logout-link {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #00332d;
      text-decoration: underline;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      background: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
    }
    .logout-link:hover {
      color: #00796b;
    }
  </style>
</head>
<body>

<!-- LOADING OVERLAY -->
<div id="loadingOverlay">
  <div class="loadingBox">
    <div class="overlaySpinner"></div>
    <div>Loading tasks, please wait...</div>
  </div>
</div>

<!-- LOGIN OVERLAY -->
<div id="loginOverlay">
  <div class="login-container">
    <div class="login-header">
      AutonomyWorks <i class="fa-solid fa-briefcase"></i>
    </div>
    <input id="username" placeholder="Username" onkeydown="checkEnter(event)">
    <input id="password" type="password" placeholder="Password" onkeydown="checkEnter(event)">
    <button onclick="login()">Login</button>
    <!-- 3-dot wave spinner -->
    <div id="loginSpinner">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
</div>

<!-- MAIN TASK SCREEN -->
<div id="taskScreen">
  <div id="notificationBar"></div>
  <h2 id="greeting"></h2>

  <!-- Start Task / Refresh -->
  <div style="text-align:center;">
    <button id="startTaskBtn" onclick="startTaskClicked()">Start Task</button>
    <div id="startSpinner" class="spinner-wheel"></div>
  </div>

  <!-- Task detail in grid -->
  <div id="taskDetail" style="margin-top: 20px;"></div>

  <div id="statusOptions">
    <!-- RADIO BUTTONS -->
    <div class="status-container">
      <label>
        <input type="radio" name="status" value="In Progress" onchange="handleStatusChange()">
        In Progress<span style="color:red;">*</span>
      </label>
      <label>
        <input type="radio" name="status" value="Issue" onchange="handleStatusChange()">
        Issue<span style="color:red;">*</span>
      </label>
      <label>
        <input type="radio" name="status" value="Completed" onchange="handleStatusChange()">
        Completed
      </label>
    </div>

    <!-- NOTES (hidden until a radio is chosen) -->
    <textarea
      id="notes"
      rows="3"
      placeholder="Associate Notes (required for In Progress or Issue)"
    ></textarea>

    <!-- STOP TASK + spinner at the bottom -->
    <div class="stop-task-container">
      <button class="stop-btn" onclick="stopTask()">Stop Task</button>
      <div id="stopSpinner"></div>
    </div>
  </div>

  <span class="logout-link" onclick="logout()">Log Out</span>
</div>

<!-- ON CALL MODAL -->
<div id="onCallModal">
  <h3>
    On Call: Please refresh every five minutes. 
    If you are still On Call after 15 minutes, please reach out to your Lead.
  </h3>
  <iframe src="https://chromedino.com/" allowfullscreen></iframe>
  <p style="line-height:1.4;">
    You can close this game or hit “Refresh” to check for tasks again.
  </p>
  <button onclick="closeOnCall()" style="margin-top:10px;">Close Game</button>
</div>

<script>
/* 
  ============================
  CONFIG / GLOBALS
  ============================
  This single Google Sheet is called "Workflow Assignments" with tabs:
    1) Backend (Col B = "Current Status:", Col C = "Time:")
    2) Task Data
    3) Task History

  And two other references:
    - LaSalle Pod (for user login info)
    - Question Associates (to find direct question contact)
*/
const SHEETDB_BASE       = "https://sheetdb.io/api/v1/dmn6n7fcwh80m";
const BACKEND_URL        = SHEETDB_BASE + "?sheet=Backend";
const TASK_DATA_URL      = SHEETDB_BASE + "?sheet=Task%20Data";
const TASK_HISTORY_URL   = SHEETDB_BASE + "?sheet=Task%20History";
const LASALLE_POD_URL    = SHEETDB_BASE + "?sheet=LaSalle%20Pod";
const QUESTION_ASSOC_URL = SHEETDB_BASE + "?sheet=Question%20Associates";
const HARDCODED_PASS     = "abc123";

let userFullName = "";
let tasks        = [];
let currentTask  = null;
let startTime    = null; // So we can compute cumulative time on stop

/* ============================
   HELPER FUNCTIONS
   ============================ */
function setNotification(msg, isError=false) {
  const bar = document.getElementById("notificationBar");
  if (!msg) {
    bar.style.display = "none";
    bar.innerText = "";
    return;
  }
  bar.style.display = "block";
  bar.style.color   = isError ? "red" : "#0f5132";
  bar.innerText     = msg;
}

function highlightInput(inputId, shouldHighlight) {
  const el = document.getElementById(inputId);
  if (!el) return;
  if (shouldHighlight) el.classList.add("input-error");
  else el.classList.remove("input-error");
}

/** Show/hide an overlay that indicates loading. */
function showLoadingOverlay(isShown) {
  const overlay = document.getElementById("loadingOverlay");
  overlay.style.display = isShown ? "flex" : "none";
}

/** Format Date => "MM/DD/YYYY HH:mm:ss" */
function formatDateTime(d) {
  if (!(d instanceof Date)) return "";
  const pad = (num) => (num < 10 ? "0" + num : "" + num);
  const mm   = pad(d.getMonth()+1);
  const dd   = pad(d.getDate());
  const yyyy = d.getFullYear();
  const hh   = pad(d.getHours());
  const min  = pad(d.getMinutes());
  const sec  = pad(d.getSeconds());
  return `${mm}/${dd}/${yyyy} ${hh}:${min}:${sec}`;
}

/** Compute a cumulative time between two dates => "H:MM:SS" */
function computeCumulativeTime(start, stop) {
  if (!start || !stop) return "";
  const diffMs   = stop - start;
  const totalSec = Math.floor(diffMs / 1000);
  const hours    = Math.floor(totalSec / 3600);
  const minutes  = Math.floor((totalSec % 3600) / 60);
  const seconds  = totalSec % 60;
  const pad = (n) => (n < 10 ? "0" + n : "" + n);
  return `${hours}:${pad(minutes)}:${pad(seconds)}`;
}

/* 
  Patch the "Backend" row by searching "Job Code:" 
  => Update "Current Status:" (col B) and "Time:" (col C)
*/
async function updateBackend(jobCode, newStatus, newTime) {
  try {
    console.log("[debug] Updating backend for code:", jobCode, "status:", newStatus, "time:", newTime);
    const searchUrl = BACKEND_URL + "/search?search_by=Job%20Code:&update_only=true";
    const bodyObj   = {
      data: [{
        "Job Code:": jobCode,
        "Current Status:": newStatus,
        "Time:": newTime
      }]
    };
    const resp = await fetch(searchUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(bodyObj)
    });
    const result = await resp.json();
    console.log("[debug] updateBackend result =>", result);
  } catch(e) {
    throw new Error("Error updating Backend: " + e.message);
  }
}

/* Insert row to Task Data or Task History with these columns: 
   Update:, Start Time:, Stop Time:, Priority:, Associate:, Status:, Client:, Task:, 
   Deliverable Name:, Deliverable ID:, Parameter 1:, Parameter 2:, Production Notes:, 
   Due Time:, Due Date:, Associate Notes:, Job Code:, Cumulative Time:
*/
async function insertRow(url, rowObj) {
  try {
    const resp = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: [ rowObj ] })
    });
    const js = await resp.json();
    console.log("[debug] insertRow to", url, " =>", js);
  } catch(e) {
    throw new Error(`Error inserting row into ${url}: ` + e.message);
  }
}

/* Build a row for Task Data / Task History insertion. */
function buildLogRow(task, startTimeStr, stopTimeStr, cTimeStr, status, notes) {
  return {
    "Update:": "FALSE",
    "Start Time:": startTimeStr || "",
    "Stop Time:": stopTimeStr || "",
    "Priority:": task["Priority:"] || "",
    "Associate:": task["Associate:"] || "",
    "Status:": status,
    "Client:": task["Client:"] || "",
    "Task:": task["Task:"] || "",
    "Deliverable Name:": task["Deliverable Name:"] || "",
    "Deliverable ID:": task["Deliverable ID:"] || "",
    "Parameter 1:": task["Parameter 1:"] || "",
    "Parameter 2:": task["Parameter 2:"] || "",
    "Production Notes:": task["Production Notes:"] || "",
    "Due Time:": task["Due Time:"] || "",
    "Due Date:": task["Due Date:"] || "",
    "Associate Notes:": notes || "",
    "Job Code:": task["Job Code:"] || "",
    "Cumulative Time:": cTimeStr || ""
  };
}

/*
  "Direct Questions To": before returning a name from 
  "Primary Contact", "Secondary Contact", "Backup Contact",
  we check if that associate has an entry in Task Data for the current day.
  If not, we fallback to the next contact.

  This is a simplified approach that might do multiple fetches. 
  If none have an entry for today, we return the primary anyway
  (or you can return a message like "No available contact" if you prefer).
*/
async function findDirectQuestion(clientName) {
  try {
    const qaRes  = await fetch(QUESTION_ASSOC_URL);
    const qaData = await qaRes.json();
    if (!Array.isArray(qaData)) return "";

    const row = qaData.find(r => (r.Client||"").trim().toLowerCase() === clientName.toLowerCase());
    if (!row) return "";

    const contactsToCheck = [
      row["Primary Contact"] || "",
      row["Secondary Contact"] || "",
      row["Backup Contact"] || ""
    ].filter(Boolean); // remove empty strings

    // fetch Task Data for today's entries
    const tdRes  = await fetch(TASK_DATA_URL);
    const tdData = await tdRes.json();
    if (!Array.isArray(tdData)) return contactsToCheck[0] || "";

    const todayStr = getTodayString(); // "MM/DD/YYYY"
    // We'll see if any contact has a "Start Time:" containing todayStr
    // or "Due Date:" containing todayStr if you'd prefer. 
    // We'll do "Start Time:" for demonstration.

    for (let contact of contactsToCheck) {
      const foundToday = tdData.some(tdRow => {
        const assoc   = (tdRow["Associate:"] || "").trim().toLowerCase();
        const startTm = (tdRow["Start Time:"] || "");
        return assoc === contact.trim().toLowerCase() && startTm.includes(todayStr);
      });
      if (foundToday) {
        return contact; // first contact with an entry for today
      }
    }
    // If none had an entry, fallback to the first contact or blank
    return contactsToCheck[0] || "";
  } catch(e) {
    console.error("Error in findDirectQuestion =>", e);
    return "";
  }
}

/** Return today's date as "MM/DD/YYYY". */
function getTodayString() {
  const d = new Date();
  const mm = d.getMonth() + 1;
  const dd = d.getDate();
  const yyyy = d.getFullYear();
  return `${mm}/${dd}/${yyyy}`;
}

/* Hide statuses, notes, detail, etc. */
function resetScreen() {
  document.getElementById("statusOptions").style.display = "none";
  document.getElementById("notes").value = "";
  document.getElementById("notes").style.display = "none";
  currentTask = null;
  startTime   = null;
  document.getElementById("taskDetail").innerHTML = "";
}

/** Whenever user picks a status, show the notes box. */
function handleStatusChange() {
  const notes = document.getElementById("notes");
  notes.style.display = "block"; 
}


/* ============================
   AUTH / LOGIN
   ============================ */
function checkEnter(e) {
  if (e.key === "Enter") login();
}

async function login() {
  const user = document.getElementById("username").value.trim().toLowerCase();
  const pass = document.getElementById("password").value.trim();
  const spinner = document.getElementById("loginSpinner");
  setNotification("");

  highlightInput("username", !user);
  highlightInput("password", !pass);

  if (!user || !pass) {
    setNotification("Username and Password are required.", true);
    return;
  }
  if (pass !== HARDCODED_PASS) {
    setNotification("Invalid login credentials.", true);
    return;
  }

  spinner.style.display = "block";
  try {
    const res  = await fetch(LASALLE_POD_URL);
    const data = await res.json();
    spinner.style.display = "none";

    const found = data.find(
      row => (row["Username"]||"").trim().toLowerCase() === user
    );
    if (!found) {
      setNotification("User not found in LaSalle Pod.", true);
      return;
    }
    const fName = (found["First Name"]||"").trim();
    const lName = (found["Last Name"] ||"").trim();
    userFullName = fName + " " + lName;

    document.getElementById("greeting").textContent = `Hello, ${userFullName}!`;
    document.getElementById("loginOverlay").style.display = "none";
    document.getElementById("taskScreen").style.display   = "block";
  } catch(err) {
    spinner.style.display = "none";
    if (err instanceof TypeError) {
      setNotification("Network error - check your connection.", true);
    } else {
      setNotification("Error fetching login data: " + err.message, true);
    }
  }
}


/* ============================
   TASK START / REFRESH
   ============================ */
function startTaskClicked() {
  setNotification("");
  document.getElementById("startTaskBtn").style.display = "none";
  document.getElementById("startSpinner").style.display  = "block";
  // Also show our loading overlay for clarity
  showLoadingOverlay(true);

  loadReadyTasks();
}

async function loadReadyTasks() {
  try {
    const res  = await fetch(BACKEND_URL);
    const data = await res.json();

    tasks = data.filter(r => {
      const assoc  = (r["Associate:"] || "").trim().toLowerCase();
      const status = (r["Status:"]    || "").trim().toLowerCase();
      return assoc === userFullName.toLowerCase() && status === "ready";
    });

    showLoadingOverlay(false);
    document.getElementById("startSpinner").style.display = "none";

    // If no tasks => On Call scenario
    if (!tasks.length) {
      setNotification("You are on call. No tasks found.");
      const startBtn = document.getElementById("startTaskBtn");
      startBtn.style.display = "inline-block";
      startBtn.innerText = "Refresh";
      document.getElementById("onCallModal").style.display = "block";
      setTimeout(() => {
        setNotification("Reminder: Please refresh every 5 mins.");
      }, 300000);
      return;
    }

    // Found at least 1 "Ready" task
    currentTask = tasks[0];
    document.getElementById("onCallModal").style.display = "none";
    document.getElementById("startTaskBtn").style.display = "none";

    await markTaskAsStarted(currentTask);
    await displayTaskDetails(currentTask);
    document.getElementById("statusOptions").style.display = "block";

  } catch(err) {
    showLoadingOverlay(false);
    document.getElementById("startSpinner").style.display = "none";
    document.getElementById("startTaskBtn").style.display = "inline-block";

    if (err instanceof TypeError) {
      setNotification("Network error loading tasks.", true);
    } else {
      setNotification("Error loading tasks: " + err.message, true);
    }
  }
}

async function markTaskAsStarted(task) {
  startTime = new Date();
  const startStr = formatDateTime(startTime);
  try {
    // Update the Backend tab => column B => "Started", column C => "Start: <time>"
    await updateBackend(task["Job Code:"], "Started", `Start: ${startStr}`);

    // Insert row in Task Data + Task History
    const rowObj = buildLogRow(
      task,
      startStr,
      "",      // no stop time yet
      "",      // no cumulative time
      "Started",
      ""       // no notes
    );
    await insertRow(TASK_DATA_URL, rowObj);
    await insertRow(TASK_HISTORY_URL, rowObj);
  } catch(e) {
    setNotification("Error marking task as started: " + e.message, true);
  }
}


/* ============================
   TASK DISPLAY & STOP
   ============================ */
async function displayTaskDetails(task) {
  if (!task) {
    document.getElementById("taskDetail").innerHTML = "<p>No tasks to display.</p>";
    return;
  }
  const qAssoc = await findDirectQuestion((task["Client:"]||"").trim());
  document.getElementById("taskDetail").innerHTML = `
    <div class="details-grid">
      <div><b>Client:</b> ${task["Client:"] || ""}</div>
      <div><b>Parameter 1:</b> ${task["Parameter 1:"] || ""}</div>
      <div><b>Task:</b> ${task["Task:"] || ""}</div>
      <div><b>Parameter 2:</b> ${task["Parameter 2:"] || ""}</div>
      <div><b>Deliverable Name:</b> ${task["Deliverable Name:"] || ""}</div>
      <div><b>Production Notes:</b> ${task["Production Notes:"] || ""}</div>
      <div><b>Direct Questions To:</b> ${qAssoc || ""}</div>
      <div><b>Due Time:</b> ${task["Due Time:"] || ""}</div>
    </div>
  `;
}

/*
  Stop the task => "In Progress", "Issue", or "Completed".
  If "In Progress" or "Issue" => require notes.
  If "Completed" => notes optional.
  Then reset to show the Start Task button again.
*/
async function stopTask() {
  setNotification("");
  document.getElementById("stopSpinner").style.display  = "block";
  document.querySelector(".stop-btn").style.display      = "none";

  if (!currentTask) {
    setNotification("No current task to stop.", true);
    endStopSpinner();
    return;
  }

  // Which radio is selected
  let chosen = "";
  const radios = document.getElementsByName("status");
  for (let i=0; i<radios.length; i++) {
    if (radios[i].checked) {
      chosen = radios[i].value;
      break;
    }
  }
  if (!chosen) {
    setNotification("Please select a status first.", true);
    endStopSpinner();
    return;
  }

  // Check notes
  const notesField = document.getElementById("notes");
  const notes = notesField.value.trim();
  const requiresNotes = (chosen === "In Progress" || chosen === "Issue");
  highlightInput("notes", requiresNotes && !notes);
  if (requiresNotes && !notes) {
    setNotification(`Notes are required for status: ${chosen}.`, true);
    endStopSpinner();
    return;
  }

  // Mark the backend
  const stopMoment   = new Date();
  const stopTimeStr  = formatDateTime(stopMoment);
  const startTimeStr = startTime ? formatDateTime(startTime) : "";
  const combinedTime = startTimeStr 
    ? `Start: ${startTimeStr} | Stop: ${stopTimeStr}`
    : `Stop: ${stopTimeStr}`;

  const cTime = (startTime && stopMoment)
    ? computeCumulativeTime(startTime, stopMoment)
    : "";

  try {
    await updateBackend(currentTask["Job Code:"], chosen, combinedTime);

    // Insert row in Task Data + Task History
    const rowObj = buildLogRow(
      currentTask,
      startTimeStr,
      stopTimeStr,
      cTime,
      chosen,
      notes
    );
    await insertRow(TASK_DATA_URL, rowObj);
    await insertRow(TASK_HISTORY_URL, rowObj);

  } catch(e) {
    setNotification("Error stopping task: " + e.message, true);
  } finally {
    resetScreen();
    endStopSpinner();

    // Show the "Start Task" button again
    const startBtn = document.getElementById("startTaskBtn");
    startBtn.style.display = "inline-block";
    startBtn.innerText = "Start Task";
  }
}

function endStopSpinner() {
  document.getElementById("stopSpinner").style.display = "none";
  document.querySelector(".stop-btn").style.display = "inline-block";
}


/* ============================
   ON CALL / LOGOUT
   ============================ */
function closeOnCall() {
  document.getElementById("onCallModal").style.display = "none";
}

function logout() {
  setNotification("");
  resetScreen();
  userFullName = "";
  document.getElementById("taskScreen").style.display   = "none";
  document.getElementById("loginOverlay").style.display = "flex";
  document.getElementById("username").value = "";
  document.getElementById("password").value = "";
}
</script>
</body>
</html>
