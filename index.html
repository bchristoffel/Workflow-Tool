<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AutonomyWorks Workflow (Updated)</title>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
  >
  <style>
    /* Basic reset / general styling */
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Segoe UI', sans-serif;
    }

    /* LOGIN OVERLAY STYLES */
    #loginOverlay {
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%;
      background:
        radial-gradient(ellipse at center, rgba(20,30,60,0.15) 0%, rgba(20,40,70,0.8) 70%, rgba(20,40,70,1) 100%),
        url('https://images.unsplash.com/photo-1542744173-8e7e53415bb0?auto=format&fit=crop&w=1350&q=80')
          no-repeat center center fixed;
      background-size: cover;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .login-container {
      background: rgba(255,255,255,0.94);
      width: 360px;
      padding: 30px;
      border-radius: 14px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.25);
      text-align: center;
    }
    .login-header {
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 24px;
      color: #0d3b66;
      margin-bottom: 24px;
    }
    .login-header i {
      margin-left: 8px;
      font-size: 24px;
      color: #000;
    }

    /* Unified input + button styling */
    .form-group {
      position: relative;
      margin-bottom: 20px;
    }
    input, button {
      width: 100%;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 15px;
      font-family: 'Segoe UI', sans-serif;
    }
    input {
      border: 1px solid #ccc;
      transition: border 0.2s;
    }
    .input-error {
      border-color: red !important;
    }
    button {
      border: none;
      background: #b2ebf2;
      color: #00332d;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #9adee6;
    }

    /* 3-Dot Wave for Login Spinner */
    #loginSpinner {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    #loginSpinner .dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin: 3px;
      background-color: #333;
      border-radius: 50%;
      animation: wave 1.2s infinite ease-in-out;
    }
    #loginSpinner .dot:nth-child(1) {
      animation-delay: 0s;
    }
    #loginSpinner .dot:nth-child(2) {
      animation-delay: 0.12s;
    }
    #loginSpinner .dot:nth-child(3) {
      animation-delay: 0.24s;
    }
    @keyframes wave {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-8px); }
    }

    /* MAIN TASK SCREEN */
    #taskScreen {
      display: none; 
      width: 100%; 
      height: 100%;
      background-color: #f0f0f0;
      overflow: auto; 
      padding: 20px;
      position: relative; /* for the logout link positioning */
    }
    #greeting {
      text-align: center;
      margin: 0 auto 20px auto;
      font-size: 22px; 
      color: #1d3330;
    }

    /* Notification Bar for success/error messages (instead of alerts) */
    #notificationBar {
      display: none; 
      width: 100%; 
      text-align: center; 
      font-weight: 600; 
      padding: 8px 0; 
      margin-bottom: 10px;
    }

    /* Task details in 2-column grid (responsive) */
    .details-grid {
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 10px;
      max-width: 800px; 
      margin: 0 auto; 
      background: #fff;
      padding: 20px; 
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    @media(max-width: 600px) {
      .details-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Status Options, Stop Task, etc. */
    #statusOptions {
      display: none; 
      margin: 20px auto; 
      max-width: 800px; 
      text-align: center;
    }
    .stop-task-container {
      margin-bottom: 20px;
      text-align: center;
    }
    .stop-btn {
      width: 150px;
      background: #b2ebf2; 
      color: #00332d; 
      font-weight: 600;
      border: none; 
      border-radius: 4px; 
      padding: 10px; 
      font-size: 15px;
      margin-top: 10px;
      font-family: 'Segoe UI', sans-serif; 
      cursor: pointer;
    }
    .stop-btn:hover {
      background: #9adee6;
    }

    /* Spinner for Start/Refresh and Stop */
    .spinner-wheel {
      display: none;
      margin: 10px auto;
      width: 30px; 
      height: 30px;
      border: 4px solid #f3f3f3; /* Light grey */
      border-top: 4px solid #333; /* Darker color for the "spinner" part */
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-container {
      display: flex; 
      justify-content: center; 
      gap: 20px;
      margin-top: 20px; /* to place them "under" the stop task button area */
    }
    #notes {
      width: 100%;
      margin-top: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      font-size: 14px;
      font-family: 'Segoe UI', sans-serif;
      transition: border 0.2s;
    }

    /* ON CALL MODAL */
    #onCallModal {
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: white; 
      padding: 20px; 
      border-radius: 14px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.25);
      text-align: center; 
      max-width: 90vw; 
      width: 600px;
      font-family:'Segoe UI', sans-serif;
    }
    iframe {
      width: 100%; 
      height: 400px; 
      border: none;
    }

    /* Logout link at bottom, centered, smaller font */
    .logout-link {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #00332d;
      text-decoration: underline;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      background: #f0f0f0; /* to blend with the screen color */
      padding: 5px 10px;
      border-radius: 4px;
    }
    .logout-link:hover {
      color: #00796b;
    }
  </style>
</head>
<body>

<!-- LOGIN OVERLAY -->
<div id="loginOverlay">
  <div class="login-container">
    <div class="login-header">
      AutonomyWorks <i class="fa-solid fa-briefcase"></i>
    </div>
    <input id="username" placeholder="Username" onkeydown="checkEnter(event)">
    <input id="password" type="password" placeholder="Password" onkeydown="checkEnter(event)">
    <button onclick="login()">Login</button>
    <!-- Login spinner (3-dot wave) -->
    <div id="loginSpinner">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
</div>

<!-- MAIN TASK SCREEN -->
<div id="taskScreen">
  <!-- Notification bar for success/error messages -->
  <div id="notificationBar"></div>

  <h2 id="greeting"></h2>

  <!-- Start Task / Refresh area with spinner -->
  <div style="text-align:center;">
    <button id="startTaskBtn" onclick="startTaskClicked()">Start Task</button>
    <div id="startSpinner" class="spinner-wheel"></div>
  </div>

  <!-- Task detail in 2 columns -->
  <div id="taskDetail" style="margin-top: 20px;"></div>

  <div id="statusOptions">
    <!-- STOP TASK + spinner -->
    <div class="stop-task-container">
      <button class="stop-btn" onclick="stopTask()">Stop Task</button>
      <div id="stopSpinner" class="spinner-wheel"></div>
    </div>

    <!-- Centered statuses below the button -->
    <div class="status-container">
      <label><input type="radio" name="status" value="In Progress">In Progress</label>
      <label><input type="radio" name="status" value="Issue">Issue</label>
      <label><input type="radio" name="status" value="Completed">Completed</label>
    </div>
    <!-- Always visible so notes can be optional for "Completed" but required otherwise -->
    <textarea
      id="notes"
      rows="3"
      placeholder="Associate Notes (required for In Progress or Issue)"
    ></textarea>
  </div>

  <span class="logout-link" onclick="logout()">Log Out</span>
</div>

<!-- ON CALL MODAL -->
<div id="onCallModal">
  <h3 style="margin-top:0;">
    On Call: Please refresh every five minutes. 
    If you are still On Call after 15 minutes, please reach out to your Lead.
  </h3>
  <iframe src="https://chromedino.com/" allowfullscreen></iframe>
  <p style="line-height:1.4;">
    You can close this game or hit “Refresh” to check for tasks again.
  </p>
  <button onclick="closeOnCall()" style="margin-top:10px;">Close Game</button>
</div>

<script>
/* =========================================================
   CONFIG / GLOBALS
   ========================================================= */

/*
  The following is how your data is read:
  - For the Backend sheet (column B => Current Status, column C => Time, etc.)
  - For Task Data and Task History, you want:
    Update:, Start Time:, Stop Time:, Priority:, Associate:, Status:, Client:, Task:, Deliverable Name:, Deliverable ID:, Parameter 1:, Parameter 2:, Production Notes:, Due Time:, Due Date:, Associate Notes:, Job Code:, Cumulative Time:
*/
const SHEETDB_BASE       = "https://sheetdb.io/api/v1/dmn6n7fcwh80m";
const BACKEND_URL        = SHEETDB_BASE + "?sheet=Backend";    
const TASK_DATA_URL      = SHEETDB_BASE + "?sheet=Task%20Data";
const TASK_HISTORY_URL   = SHEETDB_BASE + "?sheet=Task%20History";
const LASALLE_POD_URL    = SHEETDB_BASE + "?sheet=LaSalle%20Pod";
const QUESTION_ASSOC_URL = SHEETDB_BASE + "?sheet=Question%20Associates";

/* Hardcoded pass for demonstration; ideally replaced with secure auth. */
const HARDCODED_PASS     = "abc123";

/*
  We store these values in memory:
  - userFullName: The person's full name
  - tasks: The array of tasks in "Ready" status from the backend
  - currentTask: The single task user is working on
  - startTime: A Date object marking when the user started the task
*/
let userFullName = "";
let tasks        = [];
let currentTask  = null;
let startTime    = null;


/* =========================================================
   HELPER FUNCTIONS
   ========================================================= */

/**
 * Show or hide notifications with a message.
 * If isError is true, color text red. Otherwise, use a success color.
 */
function setNotification(msg, isError=false) {
  const bar = document.getElementById("notificationBar");
  if (!msg) {
    bar.style.display = "none";
    bar.innerText = "";
    return;
  }
  bar.style.display = "block";
  bar.style.color = isError ? "red" : "#0f5132";
  bar.innerText = msg;
}

/**
 * Highlight or un-highlight an input field on error.
 */
function highlightInput(inputId, shouldHighlight) {
  const el = document.getElementById(inputId);
  if (!el) return;
  if (shouldHighlight) {
    el.classList.add("input-error");
  } else {
    el.classList.remove("input-error");
  }
}

/**
 * Format a Date object as a user-friendly string (MM/DD/YYYY HH:MM:SS).
 */
function formatDateTime(d) {
  if (!(d instanceof Date)) return "";
  const pad = (num) => (num < 10 ? "0" + num : "" + num);
  const mm = pad(d.getMonth()+1);
  const dd = pad(d.getDate());
  const yyyy = d.getFullYear();
  const hh = pad(d.getHours());
  const min = pad(d.getMinutes());
  const sec = pad(d.getSeconds());
  return `${mm}/${dd}/${yyyy} ${hh}:${min}:${sec}`;
}

/**
 * Compute time difference between two Date objects and return H:MM:SS.
 */
function computeCumulativeTime(start, stop) {
  if (!start || !stop) return "";
  const diffMs = stop - start; // milliseconds
  const totalSecs = Math.floor(diffMs / 1000);
  const hours = Math.floor(totalSecs / 3600);
  const minutes = Math.floor((totalSecs % 3600) / 60);
  const seconds = totalSecs % 60;
  const pad = (n) => (n < 10 ? "0" + n : "" + n);
  return `${hours}:${pad(minutes)}:${pad(seconds)}`;
}

/**
 * Make an update to the "Backend" sheet by searching the row via "Job Code:".
 * (Column B => "Current Status:", Column C => "Time:")
 */
async function updateBackend(jobCode, status, timeString) {
  try {
    // We'll store a combined string for time if we have both start and stop times
    // For example: "Start: 04/11/2025 10:30:00 | Stop: 04/11/2025 10:45:00"
    const searchUrl = BACKEND_URL + "/search?search_by=Job%20Code:&update_only=true";
    const bodyObj   = { 
      data: [{
        "Job Code:": jobCode,
        "Current Status:": status, // e.g. "Started", "In Progress", "Completed", or "Issue"
        "Time:": timeString       // e.g. "Start: 04/11/2025 10:30:00" or "Start: ... | Stop: ..."
      }]
    };
    await fetch(searchUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(bodyObj)
    });
  } catch(e) {
    throw new Error("Error updating Backend tab: " + e.message);
  }
}

/**
 * Insert a row into either Task Data or Task History, using all relevant columns:
 *  Update:, Start Time:, Stop Time:, Priority:, Associate:, Status:, etc.
 */
async function insertIntoTaskSheet(url, rowObj) {
  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ data: [ rowObj ] })
    });
  } catch(e) {
    throw new Error("Error inserting row into " + url + ": " + e.message);
  }
}

/**
 * Build the row object for logging to Task Data / Task History.
 * We store Start Time, Stop Time, Cumulative Time, etc.
 */
function buildLogRow(task, startTimeStr, stopTimeStr, cumulativeTime, status, notes) {
  // The user wants these columns:
  // Update:, Start Time:, Stop Time:, Priority:, Associate:, Status:, Client:, Task:, Deliverable Name:,
  // Deliverable ID:, Parameter 1:, Parameter 2:, Production Notes:, Due Time:, Due Date:,
  // Associate Notes:, Job Code:, Cumulative Time:

  // We can pass "Update:" as "FALSE" or blank, if not used for anything specific
  // Priority is in the original row under "Priority:" if present
  // We'll fill in as much as we can from the original "task" row
  return {
    "Update:": "FALSE",
    "Start Time:": startTimeStr || "",
    "Stop Time:": stopTimeStr || "",
    "Priority:": task["Priority:"] || "",
    "Associate:": task["Associate:"] || "",
    "Status:": status,
    "Client:": task["Client:"] || "",
    "Task:": task["Task:"] || "",
    "Deliverable Name:": task["Deliverable Name:"] || "",
    "Deliverable ID:": task["Deliverable ID:"] || "",
    "Parameter 1:": task["Parameter 1:"] || "",
    "Parameter 2:": task["Parameter 2:"] || "",
    "Production Notes:": task["Production Notes:"] || "",
    "Due Time:": task["Due Time:"] || "",
    "Due Date:": task["Due Date:"] || "",
    "Associate Notes:": notes || "",
    "Job Code:": task["Job Code:"] || "",
    "Cumulative Time:": cumulativeTime || ""
  };
}

/**
 * Helper to fetch the direct question contact from "Question Associates."
 */
async function findDirectQuestion(clientName) {
  try {
    const qaRes  = await fetch(QUESTION_ASSOC_URL);
    const qaData = await qaRes.json();
    if (!Array.isArray(qaData)) return "";
    const row = qaData.find(
      r => (r.Client||"").trim().toLowerCase() === clientName.toLowerCase()
    );
    if (!row) return "";
    return row["Primary Contact"] || row["Secondary Contact"] || row["Backup Contact"] || "";
  } catch(e) {
    console.error("Error fetching Q/A =>", e);
    return "";
  }
}

/**
 * Reset screen after we stop or complete a task:
 * Hide status stuff, clear the detail area, etc.
 */
function resetScreen() {
  document.getElementById("statusOptions").style.display = "none";
  document.getElementById("notes").value = "";
  // Clear current task and detail
  currentTask = null;
  startTime   = null;  // reset the local start time
  document.getElementById("taskDetail").innerHTML = "";
}


/* =========================================================
   AUTH / LOGIN
   ========================================================= */

/** If user presses Enter, attempt login. */
function checkEnter(e) {
  if (e.key === "Enter") {
    login();
  }
}

/** Validate user input, fetch user data from LaSalle Pod, set screen if valid. */
async function login() {
  const user    = document.getElementById("username").value.trim().toLowerCase();
  const pass    = document.getElementById("password").value.trim();
  const spinner = document.getElementById("loginSpinner");
  setNotification(""); // clear any old messages

  highlightInput("username", !user);
  highlightInput("password", !pass);

  if (!user || !pass) {
    setNotification("Username and Password are required.", true);
    return;
  }
  if (pass !== HARDCODED_PASS) {
    setNotification("Invalid login credentials.", true);
    return;
  }

  spinner.style.display = "block";
  try {
    const res  = await fetch(LASALLE_POD_URL);
    const data = await res.json();
    spinner.style.display = "none";

    const found = data.find(
      row => (row["Username"]||"").trim().toLowerCase() === user
    );
    if (!found) {
      setNotification("User not found in LaSalle Pod.", true);
      return;
    }
    const fName = (found["First Name"]||"").trim();
    const lName = (found["Last Name"] ||"").trim();
    userFullName = fName + " " + lName;

    document.getElementById("greeting").textContent = "Hello, " + userFullName + "!";
    document.getElementById("loginOverlay").style.display = "none";
    document.getElementById("taskScreen").style.display   = "block";
  } catch(err) {
    spinner.style.display = "none";
    if (err instanceof TypeError) {
      setNotification("Network error - check your connection.", true);
    } else {
      setNotification("Error fetching login data: " + err.message, true);
    }
  }
}


/* =========================================================
   TASK START / REFRESH
   ========================================================= */

/**
 * Allows user to hit “Start Task.” 
 * If no tasks found => user is on call, the button is renamed “Refresh.”
 */
function startTaskClicked() {
  setNotification("");
  document.getElementById("startTaskBtn").style.display = "none";
  document.getElementById("startSpinner").style.display = "block";
  loadReadyTasks();
}

/**
 * Fetch “Backend” data, filter for tasks with “Ready” status belonging to user.
 * If none => On Call scenario. If some => load the first, mark as started.
 */
async function loadReadyTasks() {
  try {
    const res  = await fetch(BACKEND_URL);
    const data = await res.json();

    tasks = data.filter(r => {
      const assoc  = (r["Associate:"] || "").trim().toLowerCase();
      const status = (r["Status:"]    || "").trim().toLowerCase();
      return assoc === userFullName.toLowerCase() && status === "ready";
    });

    document.getElementById("startSpinner").style.display = "none";

    if (!tasks.length) {
      // ON CALL scenario
      setNotification("You are on call. No tasks found.");
      const startBtn = document.getElementById("startTaskBtn");
      startBtn.style.display = "inline-block";
      startBtn.innerText = "Refresh"; // rename the button only if no tasks found
      document.getElementById("onCallModal").style.display = "block";

      // 5-minute reminder
      setTimeout(() => {
        setNotification("Reminder: Please refresh every 5 mins.");
      }, 300000);
      return;
    }

    // Found at least 1 "Ready" task
    currentTask = tasks[0];
    document.getElementById("onCallModal").style.display = "none";
    document.getElementById("startTaskBtn").style.display = "none";

    // Mark the task as "Started" in column B of Backend, store startTime, etc.
    await markTaskAsStarted(currentTask);
    await displayTaskDetails(currentTask);
    document.getElementById("statusOptions").style.display = "block";

  } catch(err) {
    document.getElementById("startSpinner").style.display = "none";
    document.getElementById("startTaskBtn").style.display = "inline-block";
    if (err instanceof TypeError) {
      setNotification("Network error loading tasks.", true);
    } else {
      setNotification("Error loading tasks: " + err.message, true);
    }
  }
}

/**
 * Mark the task as “Started” in the backend (column B => "Started"),
 * record the start time in column C => "Time:" => “Start: 04/12/2025 …”
 * Also store the start time in memory for calculating stop time & cumulative time.
 */
async function markTaskAsStarted(task) {
  startTime = new Date(); // store in memory for later use
  const startTimeStr = formatDateTime(startTime);

  try {
    // 1) Update the "Backend" tab
    //    Column B => “Started”, Column C => “Start: <timestamp>”
    await updateBackend(task["Job Code:"], "Started", `Start: ${startTimeStr}`);

    // 2) Insert row into Task Data + Task History with "Start Time:" set
    const logRow = buildLogRow(
      task,
      startTimeStr, // Start Time:
      "",           // Stop Time: (not yet known)
      "",           // Cumulative Time: (no stop yet)
      "Started",    // Status:
      ""            // notes
    );
    await insertIntoTaskSheet(TASK_DATA_URL, logRow);
    await insertIntoTaskSheet(TASK_HISTORY_URL, logRow);

    setNotification("Task started successfully.");
  } catch(e) {
    setNotification("Error marking task as started: " + e.message, true);
  }
}


/* =========================================================
   TASK DISPLAY & STOP
   ========================================================= */

/**
 * Show the details of the current task in a 2-column grid.
 */
async function displayTaskDetails(task) {
  if (!task) {
    document.getElementById("taskDetail").innerHTML = "<p>No tasks to display.</p>";
    return;
  }
  const qAssoc = await findDirectQuestion((task["Client:"]||"").trim());

  // Hidden deliverable ID row removed from your original snippet
  // but we keep the same format otherwise
  document.getElementById("taskDetail").innerHTML = `
    <div class="details-grid">
      <div><b>Client:</b> ${task["Client:"] || ""}</div>
      <div><b>Parameter 1:</b> ${task["Parameter 1:"] || ""}</div>
      <div><b>Task:</b> ${task["Task:"] || ""}</div>
      <div><b>Parameter 2:</b> ${task["Parameter 2:"] || ""}</div>
      <div><b>Deliverable Name:</b> ${task["Deliverable Name:"] || ""}</div>
      <div><b>Production Notes:</b> ${task["Production Notes:"] || ""}</div>
      <div><b>Direct Questions To:</b> ${qAssoc || ""}</div>
      <div><b>Due Time:</b> ${task["Due Time:"] || ""}</div>
    </div>
  `;
}

/**
 * Stop the current task. We require notes if status is “In Progress” or “Issue”.
 * We do not require notes if “Completed”. After “Completed”, return to start screen.
 */
async function stopTask() {
  setNotification("");
  document.getElementById("stopSpinner").style.display = "block";
  document.querySelector(".stop-btn").style.display = "none";

  if (!currentTask) {
    setNotification("No current task to stop.", true);
    endStopSpinner();
    return;
  }

  // Find which radio is selected
  const radios = document.getElementsByName("status");
  let chosen = "";
  for (let i = 0; i < radios.length; i++) {
    if (radios[i].checked) {
      chosen = radios[i].value;
      break;
    }
  }
  if (!chosen) {
    setNotification("Please select a status first.", true);
    endStopSpinner();
    return;
  }

  // Associate Notes required if "In Progress" or "Issue"
  const notesField = document.getElementById("notes");
  const notes = notesField.value.trim();
  const requiresNotes = (chosen === "In Progress" || chosen === "Issue");
  highlightInput("notes", requiresNotes && !notes);

  if (requiresNotes && !notes) {
    setNotification(`Notes are required for status: ${chosen}.`, true);
    endStopSpinner();
    return;
  }

  // Mark the task as In Progress / Completed / Issue in the "Backend"
  // Also set the time column to “Start: <start> | Stop: <stop>”
  const stopTime = new Date();
  const stopTimeStr = formatDateTime(stopTime);
  const startTimeStr = startTime ? formatDateTime(startTime) : ""; // fallback if missing
  const combinedTimeString = startTimeStr
    ? `Start: ${startTimeStr} | Stop: ${stopTimeStr}`
    : `Stop: ${stopTimeStr}`; // if we somehow lost our startTime

  // Compute cumulative time
  const cTime = (startTime && stopTime) 
    ? computeCumulativeTime(startTime, stopTime)
    : "";

  try {
    // 1) Update the "Backend" row
    //    Column B => chosen (In Progress, Completed, Issue)
    //    Column C => “Start: ... | Stop: ...”
    await updateBackend(currentTask["Job Code:"], chosen, combinedTimeString);

    // 2) Insert row in Task Data + Task History with Start Time, Stop Time, Cumulative Time
    const logRow = buildLogRow(
      currentTask,
      startTimeStr,
      stopTimeStr,
      cTime,
      chosen,
      notes
    );
    await insertIntoTaskSheet(TASK_DATA_URL, logRow);
    await insertIntoTaskSheet(TASK_HISTORY_URL, logRow);

    setNotification("Task updated successfully!");
  } catch(e) {
    setNotification("Error stopping task: " + e.message, true);
  } finally {
    resetScreen();
    endStopSpinner();

    // If the user stopped with “Completed”, return to the start screen
    if (chosen === "Completed") {
      // Show "Start Task" button so user can pick next
      const startBtn = document.getElementById("startTaskBtn");
      startBtn.style.display = "block";
      startBtn.innerText = "Start Task";
    }
  }
}

/** Helper to restore the stop button, hide spinner. */
function endStopSpinner() {
  document.getElementById("stopSpinner").style.display = "none";
  document.querySelector(".stop-btn").style.display = "inline-block";
}


/* =========================================================
   ON CALL / LOGOUT
   ========================================================= */

/** Close the on-call modal but keep the "Refresh" or "Start Task" button. */
function closeOnCall() {
  document.getElementById("onCallModal").style.display = "none";
}

/** 
 * Log out => Clear user info, reset screen, show login overlay again.
 */
function logout() {
  setNotification("");
  resetScreen();
  userFullName = "";
  document.getElementById("taskScreen").style.display   = "none";
  document.getElementById("loginOverlay").style.display = "flex";
  document.getElementById("username").value = "";
  document.getElementById("password").value = "";
}
</script>
</body>
</html>
